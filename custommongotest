import com.appsmith.external.models.BaseDomain;
import com.mongodb.client.result.UpdateResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.autoconfigure.mongo.MongoProperties;
import org.springframework.data.mongodb.MongoDatabaseFactory;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.convert.MongoConverter;
import org.springframework.data.mongodb.core.mapping.MongoMappingContext;
import org.springframework.data.mongodb.core.mapping.MongoPersistentEntity;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CustomMongoTemplateTest {

    @Mock
    private MongoDatabaseFactory mongoDbFactory;

    @Mock
    private MongoConverter mongoConverter;

    @Mock
    private MongoProperties mongoProperties;

    @Mock
    private MongoTemplate mongoTemplate;

    @Mock
    private MongoMappingContext mappingContext;

    @InjectMocks
    private CustomMongoTemplate customMongoTemplate;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        when(mongoConverter.getMappingContext()).thenReturn(mappingContext);
    }
    static class TestDomain extends BaseDomain {
        String name;

        public TestDomain(String id, String name) {
            this.setId(id);
            this.name = name;
        }
    }

    // 通过 updateMulti 间接测试 isCosmosDB
    @Test
    void updateMulti_cosmosDBUri_usesBatchUpdate() {
        Query query = new Query();
        Update update = new Update();
        Class<TestDomain> entityClass = TestDomain.class;

        // 设置为 CosmosDB URI
        when(mongoProperties.getUri()).thenReturn("mongodb://user:password@host.mongo.cosmos.azure.com:10255/db?ssl=true");
        when(mongoTemplate.count(query, entityClass)).thenReturn(100L); // 触发批量更新

        // 模拟批量更新的行为（模拟 find 和 updateFirst）
        List<TestDomain> batch = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            batch.add(new TestDomain("id" + i, "name" + i));
        }
        when(mongoTemplate.find(argThat(q -> q.getSkip() == 0), eq(entityClass))).thenReturn(batch.subList(0, 50));
        when(mongoTemplate.find(argThat(q -> q.getSkip() == 50), eq(entityClass))).thenReturn(batch.subList(50, 100));
        when(mongoTemplate.updateFirst(any(Query.class), any(Update.class), eq(entityClass)))
                .thenReturn(UpdateResult.acknowledged(1, 1L, null));


        UpdateResult result = customMongoTemplate.updateMulti(query, update, entityClass);

        assertEquals(100, result.getMatchedCount());
        assertEquals(100, result.getModifiedCount());
        verify(mongoTemplate, times(100)).updateFirst(any(Query.class), any(Update.class), eq(entityClass)); // 验证走了批量更新的逻辑 (多次调用 updateFirst)
        verify(mongoTemplate, never()).updateMulti(any(Query.class), any(Update.class), eq(entityClass));     // 验证没有走默认的updateMulti

        //verify find for batch
        verify(mongoTemplate).find(argThat(q -> q.getSkip() == 0), eq(entityClass));
        verify(mongoTemplate).find(argThat(q -> q.getSkip() == 50), eq(entityClass));
    }

    @Test
    void updateMulti_nonCosmosDBUri_usesDefaultUpdateMulti() {
        Query query = new Query();
        Update update = new Update();
        Class<TestDomain> entityClass = TestDomain.class;
        UpdateResult expectedResult = UpdateResult.acknowledged(1, 1L, null);

        // 设置为非 CosmosDB URI
        when(mongoProperties.getUri()).thenReturn("mongodb://localhost:27017/test");
        when(mongoTemplate.updateMulti(query, update, entityClass)).thenReturn(expectedResult);

        UpdateResult actualResult = customMongoTemplate.updateMulti(query, update, entityClass);

        assertEquals(expectedResult, actualResult);
        verify(mongoTemplate).updateMulti(query, update, entityClass); // 验证走了默认的 updateMulti 逻辑
        verify(mongoTemplate, never()).find(any(), any());          // 验证没有调用 find (即没有走批量更新)
        verify(mongoTemplate, never()).updateFirst(any(), any(), any()); // 验证没有调用 updateFirst
    }

    @Test
    void updateMulti_cosmosDB_smallBatch_success() {
        Query query = new Query();
        Update update = new Update();
        Class<TestDomain> entityClass = TestDomain.class;
        UpdateResult expectedResult = UpdateResult.acknowledged(5, 5L, null);

        when(mongoProperties.getUri()).thenReturn("mongodb://user:password@host.mongo.cosmos.azure.com:10255/db?ssl=true");
        when(mongoTemplate.count(query, entityClass)).thenReturn(5L); // 小于 SMALL_BATCH_THRESHOLD
        when(mongoTemplate.updateMulti(query, update, entityClass)).thenReturn(expectedResult);

        UpdateResult result = customMongoTemplate.updateMulti(query, update, entityClass);

        assertEquals(expectedResult, result);
        verify(mongoTemplate).updateMulti(query, update, entityClass); //small batch, 走的是super.updateMulti.
    }

    @Test
    void updateMulti_cosmosDB_smallBatch_nativeUpdateFails_fallsBackToBatch() {
        Query query = new Query();
        Update update = new Update();
        Class<TestDomain> entityClass = TestDomain.class;

        when(mongoProperties.getUri()).thenReturn("mongodb://user:password@host.mongo.cosmos.azure.com:10255/db?ssl=true");
        when(mongoTemplate.count(query, entityClass)).thenReturn(5L);
        when(mongoTemplate.updateMulti(query, update, entityClass)).thenThrow(new RuntimeException("Simulated failure"));

        List<TestDomain> batch = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            batch.add(new TestDomain("id" + i, "name" + i));
        }
        when(mongoTemplate.find(any(Query.class), eq(entityClass))).thenReturn(batch);
        when(mongoTemplate.updateFirst(any(Query.class), any(Update.class), eq(entityClass)))
                .thenReturn(UpdateResult.acknowledged(1, 1L, null)); // 模拟每次更新成功


        UpdateResult result = customMongoTemplate.updateMulti(query, update, entityClass);

        assertEquals(5, result.getMatchedCount());
        assertEquals(5, result.getModifiedCount());
        verify(mongoTemplate, times(5)).updateFirst(any(Query.class), any(Update.class), eq(entityClass));
    }


    @Test
    void updateMulti_cosmosDB_countThrowsException_exceptionPropagated() {
        Query query = new Query();
        Update update = new Update();
        Class<TestDomain> entityClass = TestDomain.class;

        when(mongoProperties.getUri()).thenReturn("mongodb://user:password@host.mongo.cosmos.azure.com:10255/db?ssl=true");
        when(mongoTemplate.count(query, entityClass)).thenThrow(new RuntimeException("Simulated count failure"));

        assertThrows(RuntimeException.class, () -> customMongoTemplate.updateMulti(query, update, entityClass));
    }


    @Test
    void getCollectionClass_entityFound_returnsClass() {
        String collectionName = "testCollection";
        MongoPersistentEntity<?> mockEntity = mock(MongoPersistentEntity.class);
        when(mockEntity.getCollection()).thenReturn(collectionName);
        when(mockEntity.getType()).thenReturn(TestDomain.class);

        when(mappingContext.getPersistentEntities()).thenReturn(Collections.singletonList(mockEntity));

        Class<?> result = customMongoTemplate.getCollectionClass(collectionName);
        assertEquals(TestDomain.class, result);

    }


    @Test
    void getCollectionClass_entityNotFound_returnsNullAndLogsWarning() {
        String collectionName = "nonExistentCollection";
        when(mappingContext.getPersistentEntities()).thenReturn(Collections.emptyList());
        Class<?> result = customMongoTemplate.getCollectionClass(collectionName);
        assertNull(result);
    }
}
